#include <SoftwareSerial.h>

// Pin definitions
#define FP_RX 2    // Arduino RX pin (connect to converter HV1)
#define FP_TX 3    // Arduino TX pin (connect to converter HV2)
#define TOUCH_PIN 4 // Optional touch detection

SoftwareSerial fpSerial(FP_RX, FP_TX);  // RX, TX (Arduino perspective)

void setup() {
  Serial.begin(115200);
  while (!Serial);  // Wait for Serial Monitor
  Serial.println(F("\n\nHR6WIC Fingerprint Sensor Test"));
  Serial.println(F("================================\n"));
  
  // Initialize fingerprint serial
  fpSerial.begin(57600);  // Default baud rate for HR6WIC
  delay(1000);
  
  Serial.println(F("Initializing communication..."));
  
  // Test 1: Basic communication
  if (testCommunication()) {
    Serial.println(F("✓ Communication established"));
  } else {
    Serial.println(F("✗ Communication failed!"));
    Serial.println(F("Check:"));
    Serial.println(F("1. HR6WIC is powered with 3.3V"));
    Serial.println(F("2. TX/RX connections are correct"));
    Serial.println(F("3. Logic level converter is properly connected"));
    Serial.println(F("4. All GND are connected together"));
    while(1); // Halt
  }
  
  // Test 2: Get sensor information
  getSensorInfo();
  
  // Test 3: Check for fingerprints in database
  checkFingerprintCount();
  
  Serial.println(F("\nReady for commands:"));
  Serial.println(F("E = Enroll new fingerprint"));
  Serial.println(F("S = Search for fingerprint"));
  Serial.println(F("D = Delete fingerprint"));
  Serial.println(F("C = Clear all fingerprints"));
  Serial.println(F("T = Test touch sensor"));
  Serial.println(F("R = Read raw sensor data"));
}

void loop() {
  // Handle serial commands
  if (Serial.available()) {
    char command = Serial.read();
    processCommand(command);
  }
  
  // Optional: Auto-detect finger via touch pin
  if (TOUCH_PIN != 255) {  // Change to your pin or remove if not using
    static bool lastTouchState = false;
    bool currentTouchState = digitalRead(TOUCH_PIN);
    
    if (currentTouchState && !lastTouchState) {
      Serial.println(F("\nFinger detected via touch pin!"));
      searchFingerprint();
      delay(1000); // Debounce
    }
    lastTouchState = currentTouchState;
  }
}

// ==================== CORE FUNCTIONS ====================

bool testCommunication() {
  // Send "Get Image" command to test communication
  byte cmd[] = {0xEF, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x03, 0x01, 0x00, 0x05};
  
  fpSerial.write(cmd, sizeof(cmd));
  delay(200);
  
  // Check for response
  if (fpSerial.available() >= 12) {
    byte response[12];
    fpSerial.readBytes(response, 12);
    
    Serial.print(F("Response: "));
    for (int i = 0; i < 12; i++) {
      Serial.print(response[i], HEX);
      Serial.print(" ");
    }
    Serial.println();
    
    // Check if response indicates success
    if (response[6] == 0x01 && response[9] == 0x00) {
      return true;
    }
  }
  return false;
}

void getSensorInfo() {
  // Get system parameters
  byte cmd[] = {0xEF, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x03, 0x0F, 0x00, 0x13};
  
  fpSerial.write(cmd, sizeof(cmd));
  delay(300);
  
  if (fpSerial.available() >= 16) {
    byte response[16];
    fpSerial.readBytes(response, 16);
    
    Serial.println(F("\n=== Sensor Information ==="));
    Serial.print(F("Status: 0x")); Serial.println(response[9], HEX);
    
    uint16_t capacity = (response[11] << 8) | response[12];
    uint16_t security = response[13];
    uint16_t packetSize = (response[14] << 8) | response[15];
    
    Serial.print(F("Capacity: ")); Serial.print(capacity); Serial.println(F(" templates"));
    Serial.print(F("Security level: ")); Serial.println(security);
    Serial.print(F("Packet size: ")); Serial.println(packetSize);
  } else {
    Serial.println(F("Failed to get sensor info"));
  }
}

void checkFingerprintCount() {
  // Get template count
  byte cmd[] = {0xEF, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x03, 0x1D, 0x00, 0x21};
  
  fpSerial.write(cmd, sizeof(cmd));
  delay(200);
  
  if (fpSerial.available() >= 14) {
    byte response[14];
    fpSerial.readBytes(response, 14);
    
    if (response[9] == 0x00) {
      uint16_t count = (response[11] << 8) | response[12];
      Serial.print(F("\nFingerprints stored: ")); Serial.println(count);
    }
  }
}

// ==================== FINGERPRINT OPERATIONS ====================

void searchFingerprint() {
  Serial.println(F("\n=== Searching for fingerprint ==="));
  
  // Step 1: Get image
  byte getImage[] = {0xEF, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x03, 0x01, 0x00, 0x05};
  fpSerial.write(getImage, sizeof(getImage));
  delay(300);
  
  if (readAndCheckResponse("Get Image")) {
    // Step 2: Generate character file
    byte genChar[] = {0xEF, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x04, 0x02, 0x01, 0x00, 0x08};
    fpSerial.write(genChar, sizeof(genChar));
    delay(300);
    
    if (readAndCheckResponse("Generate Template")) {
      // Step 3: Search database
      byte searchCmd[] = {0xEF, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x08, 0x04, 0x01, 0x00, 0x00, 0x00, 0x64, 0x00, 0x73};
      fpSerial.write(searchCmd, sizeof(searchCmd));
      delay(500);
      
      if (fpSerial.available() >= 16) {
        byte response[16];
        fpSerial.readBytes(response, 16);
        
        Serial.print(F("Search response: "));
        for (int i = 0; i < 16; i++) {
          Serial.print(response[i], HEX);
          Serial.print(" ");
        }
        Serial.println();
        
        if (response[9] == 0x00) {
          uint16_t fingerID = (response[10] << 8) | response[11];
          uint16_t confidence = (response[12] << 8) | response[13];
          Serial.print(F("✓ Fingerprint found!"));
          Serial.print(F(" ID: ")); Serial.print(fingerID);
          Serial.print(F(" Confidence: ")); Serial.println(confidence);
        } else {
          Serial.println(F("✗ Fingerprint not found in database"));
        }
      }
    }
  }
}

void enrollFingerprint() {
  Serial.println(F("\n=== Enrolling New Fingerprint ==="));
  
  Serial.print(F("Enter ID number (0-999): "));
  while (!Serial.available());
  int id = Serial.parseInt();
  Serial.println(id);
  
  Serial.println(F("Place finger on sensor..."));
  delay(2000);
  
  // Enrollment process
  for (int i = 1; i <= 2; i++) {
    Serial.print(F("Capture #")); Serial.println(i);
    
    // Get image
    byte getImage[] = {0xEF, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x03, 0x01, 0x00, 0x05};
    fpSerial.write(getImage, sizeof(getImage));
    delay(500);
    
    if (!readAndCheckResponse("Get Image")) {
      Serial.println(F("Failed to capture image"));
      return;
    }
    
    // Generate template
    byte genChar[] = {0xEF, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x04, 0x02, 0x01, 0x00, 0x08};
    fpSerial.write(genChar, sizeof(genChar));
    delay(500);
    
    if (!readAndCheckResponse("Generate Template")) {
      Serial.println(F("Failed to generate template"));
      return;
    }
    
    if (i == 1) {
      Serial.println(F("Remove finger..."));
      delay(2000);
      Serial.println(F("Place same finger again..."));
      delay(2000);
    }
  }
  
  // Create model from two templates
  byte createModel[] = {0xEF, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x03, 0x05, 0x00, 0x09};
  fpSerial.write(createModel, sizeof(createModel));
  delay(500);
  
  if (!readAndCheckResponse("Create Model")) {
    Serial.println(F("Fingerprints didn't match"));
    return;
  }
  
  // Store model
  byte storeModel[] = {0xEF, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x06, 0x06, 0x01, 0x00, (byte)(id >> 8), (byte)(id & 0xFF), 0x00, 0x00};
  // Calculate checksum
  uint16_t sum = 0x01 + 0x00 + 0x06 + 0x06 + 0x01 + 0x00 + (id >> 8) + (id & 0xFF);
  storeModel[14] = (sum >> 8) & 0xFF;
  storeModel[15] = sum & 0xFF;
  
  fpSerial.write(storeModel, sizeof(storeModel));
  delay(500);
  
  if (readAndCheckResponse("Store Model")) {
    Serial.print(F("✓ Fingerprint enrolled successfully as ID "));
    Serial.println(id);
  }
}

bool deleteFingerprint(int id) {
  byte deleteCmd[] = {0xEF, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x07, 0x0C, 0x00, (byte)(id >> 8), (byte)(id & 0xFF), 0x00, 0x01, 0x00, 0x00};
  // Calculate checksum
  uint16_t sum = 0x01 + 0x00 + 0x07 + 0x0C + 0x00 + (id >> 8) + (id & 0xFF) + 0x00 + 0x01;
  deleteCmd[15] = (sum >> 8) & 0xFF;
  deleteCmd[16] = sum & 0xFF;
  
  fpSerial.write(deleteCmd, sizeof(deleteCmd));
  delay(300);
  
  if (readAndCheckResponse("Delete Fingerprint")) {
    Serial.print(F("✓ Fingerprint ID ")); Serial.print(id); Serial.println(F(" deleted"));
    return true;
  }
  return false;
}

void clearDatabase() {
  Serial.println(F("\n=== Clearing All Fingerprints ==="));
  Serial.println(F("WARNING: This will delete ALL fingerprints!"));
  Serial.print(F("Type 'YES' to confirm: "));
  
  char confirmation[10];
  readSerialString(confirmation, 10);
  
  if (strcmp(confirmation, "YES") == 0) {
    byte clearCmd[] = {0xEF, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x03, 0x0D, 0x00, 0x11};
    fpSerial.write(clearCmd, sizeof(clearCmd));
    delay(500);
    
    if (readAndCheckResponse("Clear Database")) {
      Serial.println(F("✓ All fingerprints cleared"));
    }
  } else {
    Serial.println(F("Operation cancelled"));
  }
}

// ==================== HELPER FUNCTIONS ====================

bool readAndCheckResponse(const char* operation) {
  delay(200);
  if (fpSerial.available() >= 12) {
    byte response[12];
    fpSerial.readBytes(response, 12);
    
    if (response[9] == 0x00) {
      Serial.print(F("✓ ")); Serial.println(operation);
      return true;
    } else {
      Serial.print(F("✗ ")); Serial.print(operation);
      Serial.print(F(" failed with code: 0x"));
      Serial.println(response[9], HEX);
      return false;
    }
  } else {
    Serial.print(F("✗ No response for ")); Serial.println(operation);
    return false;
  }
}

void readSerialString(char* buffer, int length) {
  memset(buffer, 0, length);
  int index = 0;
  unsigned long startTime = millis();
  
  while (millis() - startTime < 5000) {
    if (Serial.available()) {
      char c = Serial.read();
      if (c == '\n' || c == '\r') {
        buffer[index] = '\0';
        return;
      }
      if (index < length - 1) {
        buffer[index++] = c;
      }
    }
  }
  buffer[index] = '\0';
}

void processCommand(char command) {
  switch (command) {
    case 'e':
    case 'E':
      enrollFingerprint();
      break;
      
    case 's':
    case 'S':
      searchFingerprint();
      break;
      
    case 'd':
    case 'D':
      Serial.print(F("Enter ID to delete: "));
      while (!Serial.available());
      int delId = Serial.parseInt();
      deleteFingerprint(delId);
      break;
      
    case 'c':
    case 'C':
      clearDatabase();
      break;
      
    case 't':
    case 'T':
      if (TOUCH_PIN != 255) {
        Serial.print(F("Touch pin state: "));
        Serial.println(digitalRead(TOUCH_PIN));
      } else {
        Serial.println(F("Touch pin not configured"));
      }
      break;
      
    case 'r':
    case 'R':
      testRawCommunication();
      break;
      
    case 'h':
    case 'H':
    case '?':
      printHelp();
      break;
  }
  
  // Clear serial buffer
  while (Serial.available()) Serial.read();
}

void testRawCommunication() {
  Serial.println(F("\n=== Testing Raw Communication ==="));
  
  // Send test byte and see response
  for (int i = 0; i < 10; i++) {
    fpSerial.write(0x55);
    delay(100);
    
    Serial.print(F("Send: 0x55 | Receive: "));
    while (fpSerial.available()) {
      Serial.print(F("0x"));
      Serial.print(fpSerial.read(), HEX);
      Serial.print(" ");
    }
    Serial.println();
  }
}

void printHelp() {
  Serial.println(F("\n=== Available Commands ==="));
  Serial.println(F("E = Enroll new fingerprint"));
  Serial.println(F("S = Search for fingerprint"));
  Serial.println(F("D = Delete fingerprint by ID"));
  Serial.println(F("C = Clear all fingerprints"));
  Serial.println(F("T = Test touch sensor"));
  Serial.println(F("R = Test raw communication"));
  Serial.println(F("H = This help menu"));
}